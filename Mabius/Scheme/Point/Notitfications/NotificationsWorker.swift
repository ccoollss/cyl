//
//  NotificationsWorker.swift
//  Mabius
//
//  Created by Timafei Harhun on 3/13/17.
//  Copyright (c) 2017 vice3.agency. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import Foundation

protocol NotificationsWorkerInput {
    func loadNotifications(with input: Notifications.Input)
}

protocol NotificationsWorkerOutput: class {
    func didLoadNotifications(_ response: Notifications.Output)
    func didLoadMoreNotifications(_ response: Notifications.Output)
    func gotError(_ error: Error)
}

class NotificationsWorker: NotificationsWorkerInput {
    
    weak var output: NotificationsWorkerOutput?

    // MARK: - Business Logic

    func loadNotifications(with input: Notifications.Input) {
        GetNotifications(page: input.page, perPage: input.perPage).exec { result in
            switch result {
            case .value(let response):
                
                let group = DispatchGroup()
                var notifications: [Notifications.NotificationPoint] = []
                
                for notification in response.object.notifications {
                    group.enter()
                    if let id = notification.poiId, PointsDataStorage.isExistPoint(by: id) {
                        notifications.append(Notifications.NotificationPoint(notification: notification, pointTitle: (PointsDataStorage.getPoint(by: id)?.title) ?? ""))
                        group.leave()
                    } else {
                        GetPoint(pointId: notification.poiId).exec(completion: { result in
                            switch result {
                            case .value(let response):
                                notifications.append(Notifications.NotificationPoint(notification: notification, pointTitle: response.object.title ?? ""))
                                PointsDataStorage.save(point: response.object)
                                group.leave()
                            case .error(let error):
                                self.output?.gotError(error)
                                group.leave()
                            }
                        })
                    }
                }
                
                group.notify(queue: .main, execute: {
                    notifications.sort(by: { $0.notification.timestamp ?? 1 > $1.notification.timestamp ?? 0 })
                    if input.page == 1 {
                        self.output?.didLoadNotifications(Notifications.Output(page: response.object.pagination.currentPage, total: response.object.pagination.total, notifications: notifications))
                    } else {
                        self.output?.didLoadMoreNotifications(Notifications.Output(page: response.object.pagination.currentPage, total: response.object.pagination.total, notifications: notifications))
                    }
                })
                
            case .error(let error):
                self.output?.gotError(error)
            }
        }
    }
}
