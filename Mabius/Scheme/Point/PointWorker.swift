//
//  PointWorker.swift
//  Mabius
//
//  Created by Timafei Harhun on 10/03/17.
//  Copyright (c) 2017 vice3.agency. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import Foundation

protocol PointWorkerInput {
    
    func loadPoint(with id: Int)
    
    func loadComments(with input: PointDetails.Input.CommentsList)
    func addComment(with input: PointDetails.Input.Comment)
    
    func like(for point: Point)
    func removeLike(for point: Point)
}

protocol PointWorkerOutput: class {
    
    func didLoadPoint(_ response: PointDetails.Output.UserPoint)
    
    func didLoadComments(_ outour: PointDetails.Output.Comments)
    func didLoadMoreComments(_ response: PointDetails.Output.Comments)
    func didAddComment()
    
    func didLike(for point: Point)
    func didRemoveLike(for  point: Point)
    
    func gotError(_ error: Error)
}

class PointWorker: PointWorkerInput {
    
    weak var output: PointWorkerOutput?

    // MARK: - Business Logic
    
    func loadPoint(with id: Int) {
        
        var point = Point()
        
        if PointsDataStorage.isExistPoint(by: id) {
            point = PointsDataStorage.getPoint(by: id)!
            handlePoint(point)
        } else {
            GetPoint(pointId: id).exec(completion: { result in
                switch result {
                case .value(let pointResponse):
                    point = pointResponse.object
                    PointsDataStorage.save(point: point)
                    self.handlePoint(point)
                case .error(let error):
                    self.output?.gotError(error)
                }
            })
        }
    }

    func loadComments(with input: PointDetails.Input.CommentsList) {
        GetComments(pointId: input.pointId, page: input.page, perPage: input.perPage).exec { result in
            switch result {
            case .value(let response):
                // TODO: extract to separate func or class ?
                guard let comments = response.object.comments, let pagination = response.object.pagination else {
                    self.output?.gotError(NetworkError.badResponse)
                    return
                }

                let group = DispatchGroup()
                var userComments: [PointDetails.UserComment] = []

                for comment in comments {
                    guard let userId = comment.user else {
                        self.output?.gotError(NetworkError.badResponse)
                        return
                    }

                    if UsersDataStorage.isExistUser(by: userId) {
                        userComments.append(PointDetails.UserComment(user: UsersDataStorage.getUser(by: userId)!, comment: comment))
                    } else {
                        group.enter()
                        GetUser(userId: userId).exec { result in
                            switch result {
                            case .value(let response):
                                userComments.append(PointDetails.UserComment(user: response.object, comment:comment))
                                UsersDataStorage.save(user: response.object)
                                group.leave()
                            case .error(let error):
                                self.output?.gotError(error)
                                group.leave()
                            }
                        }
                    }
                }

                group.notify(queue: .main) {
                    userComments.sort(by: { $0.comment.timestamp ?? 1 > $1.comment.timestamp ?? 0 })
                    if pagination.currentPage == 1 {
                        self.output?.didLoadComments(PointDetails.Output.Comments(page: (pagination.currentPage)!, total: (pagination.total)!, comments: userComments))
                    } else {
                        self.output?.didLoadMoreComments(PointDetails.Output.Comments(page: (pagination.currentPage)!, total: (pagination.total)!, comments: userComments))
                    }
                }
            case .error(let error):
                self.output?.gotError(error)
            }
        }
     }

    func addComment(with input: PointDetails.Input.Comment) {
        
        let params = CommentParams()
        params.text = input.comment
        
        AddComment(pointId: input.pointId, params: params).exec { result in
            switch result {
            case .value(_):
                self.output?.didAddComment()
            case .error(let error):
                self.output?.gotError(error)
            }
        }
    }
    
    func like(for point: Point) {
        AddLike(pointId: point.id).exec { result in
            switch result {
            case .value(_):
                self.output?.didLike(for: point)
            case .error(let error):
                self.output?.gotError(error)
            }
        }
    }
    
    func removeLike(for point: Point) {
        RemoveLike(pointId: point.id).exec { result in
            switch result {
            case .value(_):
                self.output?.didRemoveLike(for: point)
            case .error(let error):
                self.output?.gotError(error)
            }
        }
    }

    // MARK: - Private

    private func handlePoint(_ point: Point) {
        if let owner = point.owner, UsersDataStorage.isExistUser(by: owner) {
            self.output?.didLoadPoint(PointDetails.Output.UserPoint(user: UsersDataStorage.getUser(by: owner)!, point: point))
        } else {
            GetUser(userId: point.owner).exec { result in
                switch result {
                case .value(let userResponse):
                    UsersDataStorage.save(user: userResponse.object)
                    self.output?.didLoadPoint(PointDetails.Output.UserPoint(user: userResponse.object, point: point))
                case .error(let error):
                    self.output?.gotError(error)
                }
            }
        }
    }
}
