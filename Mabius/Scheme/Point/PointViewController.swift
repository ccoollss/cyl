//
//  PointViewController.swift
//  Mabius
//
//  Created by Timafei Harhun on 10/03/17.
//  Copyright (c) 2017 vice3.agency. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

protocol PointViewControllerDelegate: class {
    func reloadFeed()
}

import UIKit

class PointViewController: BaseViewController, UITableViewDataSource, CommentCellDelegate, FeedDetailCellDelegate, FeedDetailCellDescriptionDelegate, FeedDetailCellFavoritesDelegate,PointPresenterOutput {
    
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var chatBoxContainer: Ð¡hatBoxContainer!
    @IBOutlet weak var contentBottom: NSLayoutConstraint!
    @IBOutlet weak var sendButton: UIButton!
    @IBOutlet weak var editPointButton: UIButton!
    
    fileprivate var model = PointDetails.ViewModel()
    fileprivate var batch = PointDetails.Batch()
    
    var output: PointInteractorInput!
    var router: PointRouter!

    // MARK: - Object lifecycle

    override func awakeFromNib() {
        super.awakeFromNib()
        
        PointConfigurator.instance.configure(viewController: self)
    }
    
    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 65
        
        tableView.delegate = self
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        batch.page = 0
        output.loadPoint(with: model.pointId)
    }

    // MARK: - Event handling
    
    @IBAction func shareButtonHandler(_ sender: AnyObject) {
        router.share(with: model)
    }
    
    @IBAction func editPointButtonHandler(_ sender: AnyObject) {
        router.editPoint(with: model)
    }
    
    @IBAction func sendButtonHandler(_ sender: AnyObject) {
        view.endEditing(true)
        output.addComment(with: PointDetails.Input.Comment(pointId: model.pointId, comment: chatBoxContainer.chatBox.text))
    }
    
    override func keyboardWillChangeFrame(_ notification: Foundation.Notification) {
        
        let value = notification.userInfo![UIKeyboardFrameEndUserInfoKey]
        let frame = (value as AnyObject).cgRectValue
        let kbSize = (notification.userInfo![UIKeyboardFrameBeginUserInfoKey] as AnyObject).cgRectValue.size
        let minSize: CGFloat = min(CGFloat(kbSize.width), CGFloat(kbSize.height))

        
//        if let y = frame?.origin.y {
//            if y < UIScreen.main.bounds.height {
//                contentBottom.constant = minSize + 30
//            } else {
//                contentBottom.constant = 0
//            }
//        }
        
        if (frame?.origin.y)! < UIScreen.main.bounds.height {
//            contentBottom.constant = minSize - 50
            contentBottom.constant = minSize + 50
        } else {
//            contentBottom.constant = -1
            contentBottom.constant = 0
        }
        
        UIView.animate(withDuration: 0.4, animations: {
            self.view.layoutIfNeeded()
        })
    }
    
    // MARK: - Display logic
    
    override func prepareWithParams(_ params: [String : String]) {
        if let id = params["pointId"], let intId = id.toInt() { model.pointId = intId }
        if let scroll = params["scrollToComments"], let boolScroll = scroll.toBool() { model.scrollToComments = boolScroll }
    }
    
    func didLoadPoint(_ response: PointDetails.Output.UserPoint) {
        
        model.point = response.point
        model.owner = response.user
        if let user = User.fromDefaults { editPointButton.isEnabled = user.id == model.owner.id }
        tableView.reloadData()
        
        output.loadComments(with: PointDetails.Input.CommentsList(pointId: model.pointId, page: batch.page + 1, perPage: commentsPerPage))
    }
    
    func didLoadComments(_ response: PointDetails.Output.Comments) {
        
        model.comments = response.comments
        batch.page = response.page
        batch.total = response.total
        
        tableView.reloadData()
        model.loading = false
        
        if model.scrollToComments {
            after(seconds: 0.25) {
                self.tableView.scrollToRow(at: IndexPath(row: 0, section: 1), at: .middle, animated: true)
                self.model.scrollToComments = false
            }
        }
    }
    
    func didLoadMoreComments(_ response: PointDetails.Output.Comments) {
        
        model.comments.append(contentsOf: response.comments)
        batch.page = response.page
        batch.total = response.total
        
        tableView.reloadData()
        model.loading = false
    }
    
    func didAddComment()  {
        
        chatBoxContainer.chatBox.text = ""
        if model.point.comments != nil { model.point.comments! += 1 }
        batch.page = 0
        
        model.loading = true
//        tableView.scrollToRow(at: IndexPath(row: 0, section: 1), at: .middle, animated: true)
        
        output.loadComments(with: PointDetails.Input.CommentsList(pointId: model.pointId, page: batch.page + 1, perPage: commentsPerPage))
    }
    
    func didLike(for point: Point) {
        point.isLiked = true
        if point.likes != nil { point.likes! += 1 }
        
        tableView.reloadData()
    }
    
    func didRemoveLike(for  point: Point) {
        point.isLiked = false
        if point.likes != nil { point.likes! -= 1 }
        
        tableView.reloadData()
    }
    
    func showError(_ error: String) {
        alert("Errors.error".localize(), message: error, cancel: "OK")
    }
    
    func toggleView(_ isEnabled: Bool) {
        view.isUserInteractionEnabled = isEnabled
    }
    
    // MARK: - UITableViewDataSource
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if indexPath.section == 1 { router.openUser(model.comments[indexPath.row].user.id) }
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 2
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        if section == 0 { return 4 } else { return model.comments.count }
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        if indexPath.section == 0 {
            switch indexPath.row {
                case 0:
                    if let cell = tableView.dequeueReusableCell(withIdentifier: CellType.Title.rawValue) as? FeedDetailCell {
                        cell.delegate = self
                        cell.point = model.point
                        return cell
                    }
                
                case 1:
                    if let cell = tableView.dequeueReusableCell(withIdentifier: CellType.Images.rawValue) as? FeedDetailCellImages {
                        cell.point = model.point
                        return cell
                    }
                
                case 2:
                    if let cell = tableView.dequeueReusableCell(withIdentifier: CellType.Description.rawValue) as? FeedDetailCellDescription {
                        cell.delegate = self
                        cell.user = model.owner
                        cell.point = model.point
                        return cell
                    }
                
                default:
                    if let cell = tableView.dequeueReusableCell(withIdentifier: CellType.Counters.rawValue) as? FeedDetailCellFavorites {
                        cell.delegate = self
                        cell.point = model.point
                        return cell
                    }
            }
        } else {
            if let cell = tableView.dequeueReusableCell(withIdentifier: CellType.Comment.rawValue) as? CommentCell {
                cell.delegate = self
                cell.comment = model.comments[indexPath.row].comment
                cell.user = model.comments[indexPath.row].user
                return cell
            }
        }
        
        return UITableViewCell()
    }
    
    // MARK: UIScrollViewDelegate
    
    override internal func scrollViewDidScroll(_ scrollView: UIScrollView) {
        if chatBoxContainer.chatBox.isFirstResponder { chatBoxContainer.chatBox.resignFirstResponder() }
        
        if (!model.loading && model.comments.count < batch.total) {
            let offset = scrollView.contentOffset.y;
            
            let bounds = scrollView.bounds;
            let size = scrollView.contentSize;
            let inset = scrollView.contentInset;
            let y = offset + bounds.size.height - inset.bottom;
            let h = size.height;
            
            let reloadDistance = 50;
            let position = y + CGFloat(reloadDistance)
            
            if position > h {
                model.loading = true
                output.loadComments(with: PointDetails.Input.CommentsList(pointId: model.pointId, page: batch.page + 1, perPage: commentsPerPage))
            }
        }
    }
    
    // MARK: - FeedDetailCellDelegate
    
    func tagsExpanded() {
        tableView.beginUpdates()
        tableView.endUpdates()
    }
    
    // MARK: - CommentCellDelegate
    
    func didSwipe(_ cell: CommentCell) {
        if let mention = cell.author.text, let text = chatBoxContainer.chatBox.text { chatBoxContainer.chatBox.text = "\(mention) \(text)" }
    }
    
    // MARK: - FeedDetailCellDescriptionDelegate
    
    func openPointOwner(with id: Int) {
        router.openUser(id)
    }
    
    // MARK: - FeedDetailCellFavoritesDelegate
    
    func toggleLike(for point: Point) {
        if let isLiked = point.isLiked { isLiked ? output.removeLike(for: point) : output.like(for: point) }
    }
    
    func openLikes(for pointId: Int) {
        router.openLikes(for: pointId)
    }
}
