//
//  NotificationsViewController.swift
//  Mabius
//
//  Created by Timafei Harhun on 3/13/17.
//  Copyright (c) 2017 vice3.agency. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit

class NotificationsViewController: BaseViewController, UITableViewDataSource, NotificationCellDelegate, NotificationsPresenterOutput {
    
    @IBOutlet weak var tableView: UITableView!
    
    var output: NotificationsInteractorInput!
    var router: NotificationsRouter!
    
    fileprivate lazy var refreshControl: UIRefreshControl = {
        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(handleRefresh(refreshControl:)), for: .valueChanged)
        
        return refreshControl
    }()
    
    fileprivate var model = Notifications.ViewModel()
    fileprivate var batch = Notifications.Batch()

    // MARK: - Object lifecycle

    override func awakeFromNib() {
        super.awakeFromNib()
        
        NotificationsConfigurator.instance.configure(viewController: self)
    }

    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 100
        tableView.tableFooterView = UIView()
        tableView.addSubview(refreshControl)
        
        output.loadNotifications(with: Notifications.Input(page: batch.page, perPage: notificationsPerPage))
    }

    // MARK: - Event handling

    func handleRefresh(refreshControl: UIRefreshControl) {
        batch.page = 1
        output.loadNotifications(with: Notifications.Input(page: batch.page, perPage: notificationsPerPage))
        refreshControl.endRefreshing()
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if let pointId = model.notifications[indexPath.row].poiId { router.openPoint(with: pointId) }
    }

    // MARK: - NotificationCellDelegate
    
    func openProfile(with userId: Int) {
        router.openUser(with: userId)
    }
    
    // MARK: - Display logic
    
    func didLoadNotifications(_ response: Notifications.Output) {
        model.notifications = response.notifications
        didFinishedLoading(with: response)
    }

    func didLoadMoreNotifications(_ response: Notifications.Output) {
        model.notifications.append(contentsOf: response.notifications)
        didFinishedLoading(with: response)
    }
    
    func didFinishedLoading(with response: Notifications.Output) {
        batch.page = response.page + 1
        batch.total = response.total
        
        model.loading = false
        tableView.reloadData()
    }
    
    func showError(_ error: String) {
        alert("Ошибка", message: error, cancel: "OK")
    }
    
    func toggleView(_ isEnabled: Bool) {
        view.isUserInteractionEnabled = isEnabled
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return model.notifications.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        let cell: NotificationCell = tableView.dequeueReusableCell(withIdentifier: "NotificationCell")! as! NotificationCell
        cell.delegate = self
        cell.notification = model.notifications[indexPath.row]
        return cell
    }
    
    // MARK: UIScrollViewDelegate
    
    override func scrollViewDidScroll(_ scrollView: UIScrollView) {
        
        if (!model.loading && model.notifications.count < batch.total) {
            let offset = scrollView.contentOffset.y;
            
            let bounds = scrollView.bounds;
            let size = scrollView.contentSize;
            let inset = scrollView.contentInset;
            let y = offset + bounds.size.height - inset.bottom;
            let h = size.height;
            
            let reloadDistance = 100;
            let position = y + CGFloat(reloadDistance)
            
            if position > h {
                model.loading = true
                output.loadNotifications(with: Notifications.Input(page: batch.page, perPage: notificationsPerPage))
            }
        }
    }
}
